var express = require("express");
var path = require("path");
var cookieParser = require("cookie-parser");
var logger = require("morgan");
var axios = require("axios");
const AWS = require("aws-sdk");
var app = express();
const port = "8001";
const bucketName = "n10840044-traffic-aid"
const key_QLDtrafficAPI = "QLDtrafficAPI"
const key_TopTen = "TopTen"
// S3 setup - IAM role 
const s3Client = new AWS.S3({ apiVersion: "2006-03-01" });

app.use(logger("dev"));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

//app.use(express.static("../client/build"));

// functions
async function createBucket(bucketName){
  try{
    await s3Client.createBucket({ Bucket: bucketName }).promise()
    console.log(`Created bucket: ${bucketName}`)  
  }
  catch(err){
    // We will ignore 409 errors which indicate that the bucket already
    if (err.statusCode !== 409) {
      console.log(`Error creating bucket: ${err}`);
}};}
  
async function checkBucketExists(bucket){ 
  const options = {
    Bucket: bucket,
  };
  try {
    await s3Client.headBucket(options).promise();
    console.log(`Bucket ${bucket} in the S3`)
    return true;
  } catch (error) {
    if (error.statusCode === 404) {
      return false;
    }
    throw error;
  }
};

async function getS3Object(bucketName,keyName){
  try{
    const params = { Bucket: bucketName, Key: keyName };
    const s3Result = await s3Client.getObject(params).promise();
    const s3JSON = JSON.parse(s3Result.Body);
    console.log(`Get ${keyName} successfully from S3 ${keyName}`)
    return s3JSON
  }
  catch(err){
    console.log(`Failed to get ${keyName}, error status code is ${err.statusCode}`)
    return false
  }
}

async function putS3Object(bucketName,keyName,date){
  try{
    const body = JSON.stringify(date)
    const objectParams = { Bucket: bucketName, Key: keyName, Body: body };
    await s3Client.putObject(objectParams).promise();
    console.log(`Save ${keyName} successfully to S3 ${keyName}`)
  }
  catch(err){
    console.log(`Failed to get ${keyName} from S3, error status code is ${err.statusCode}`)
    throw err
  }
}

async function fetchQLDTraffic(){
  const config = {
    method: "get",
    url: "https://api.qldtraffic.qld.gov.au/v1/webcams?apikey=3e83add325cbb69ac4d8e5bf433d770b",
  };
  const response = await axios(config)
  return response
}

function getDate(){
  const date = new Date(new Date().toUTCString())
  const day = JSON.stringify(date).slice(1,11)
  return day
}

function checkTimeStamp(apiInfo){
  const day = getDate()
  if(day != apiInfo.validity){return false}
  else{return true}
}

async function fetchQLDTrafficAPI(){
  // find the key - QLDtrafficAPI, if yes, fetch, check the validity
    var trafficInfo = await getS3Object(bucketName,key_QLDtrafficAPI)
    const validity = checkTimeStamp(trafficInfo)
    // no or invalid, fetch api, then add the timestamp
    if(!trafficInfo || !validity){
      console.log("Fetch QLDtraffic API due to no info or invalid")
      const response = await fetchQLDTraffic()
      trafficInfo = response.data.features.map((feature)=>{
      return {
        id:feature.properties.id,
        description:feature.properties.description,
        url:feature.properties.image_url,
        coordinates:feature.geometry.coordinates,
        }
      })
      trafficInfo = {source:"QLDTraffic API",validity:getDate(),info:trafficInfo}
    // save to s3
      data = {...trafficInfo}
      data.source = "S3"
      await putS3Object(bucketName,key_QLDtrafficAPI,data)
    }
    return trafficInfo
}

app.get("/init", async (req, res) => {
  try{
    // checkt the bucket
    const bucket = await checkBucketExists(bucketName)
    if(!bucket) {await createBucket(bucketName)}
    const trafficInfo = await fetchQLDTrafficAPI()
    // find the key - TopTen
    var toptenInfo = await getS3Object(bucketName,key_TopTen)
    var topTen = {}
    // no, create a location object array, add the count propery for each location, set the property to zero, then split top ten
    if(!toptenInfo){
      console.log("Generate Top Ten")
      toptenInfo = trafficInfo.info.map((location)=>{
        return{
          name:location.description,
          id:location.id,
          count:0,
        }
      })
      await putS3Object(bucketName,key_TopTen,toptenInfo)
      topTen = {source:"New",data:toptenInfo.slice(0,10)}
    }
    // yes, split to top ten
    else{ 
    topTen = {source:"S3",data:toptenInfo.slice(0,10)}
    }
    // return the locations and topten
    res.status(200).json({source:"server1",apiInfo:trafficInfo,TopTen:topTen})
  }
  catch(err){
    console.log(err)
    res.status(500).send('Status: Service Not Available')
  }
})

app.post("/traffic", async (req, res) => {
  var data = JSON.stringify(req.body);
  var config = {
    method: 'post',
    url: '物联网的复杂性意味着只能实现集中管理。可扩展、灵活的软件定义网络(software defined networking, SDN)可以解决物联网设备带来的巨大数据流量。事实上，流量和设备数量的增加是SDN开发和部署的关键驱动因素。大规模可能是物联网面临的最大挑战。到2025年，将有超过500亿台设备连接到物联网(Dange, 2020)。IDC预测，到2025年，地球上的90 ZB数据将由物联网设备产生(Sahinaslan, 2019)。各种规模的服务提供商将需要更灵活的能力来应对这些变化，它们将需要适应在某些地区快速、平稳地扩大(或缩小)网络服务的能力。



物联网设备的普及意味着人们期望的提升，而物联网如今的糟糕性能和技术落后已经严重影响了用户的日常通信、通信能力以及全球经济。软件和设备一直被添加到物联网系统中。如何降低大规模物联网网络的部署和运维成本，提高物联网设备之间数据流的传输性能和管理效率，已成为全球亟待解决的问题。

 /traffic',
    headers: { 
    'Content-Type': 'application/json'
  },
  data : data
  };
  axios(config)
  .then(function (response) {
    if(response.status == 200){
      res.status(200).json({
        source:"server2",
        ...response.data
      })
    }
    else{
      console.log(response.status)
      res.status(408).send('Status: Request Timeout')
    }
  })
  .catch(function (error) {
    res.status(404).send('Status: Not Found')
    console.log(error);
  });
  })

app.listen(port, () => {
  console.log("Server listening on port: ", port);
});

// app.use((req, res) => {
//   res.sendFile(path.join(__dirname, "../client/build", "index.html"));
// });

module.exports = app;
